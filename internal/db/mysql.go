// Package db предоставляет функции для работы с базой данных MySQL.
// Содержит глобальное соединение с БД и функции для его управления.
package db

import (
	"ctweb/internal/config" // Пакет конфигурации
	"database/sql"          // Стандартная библиотека Go для работы с БД
	"fmt"                   // Форматирование строк для ошибок
	"log"                   // Простое логирование

	// Импортируем драйвер MySQL (пустой импорт _ означает, что используем только init() функцию драйвера)
	// Драйвер регистрирует себя в database/sql при импорте
	_ "github.com/go-sql-driver/mysql"
)

// DB - глобальная переменная для хранения соединения с базой данных.
// Используется во всех местах, где нужно выполнить SQL запрос.
// После вызова Connect() эта переменная будет содержать активное соединение.
var DB *sql.DB

// Connect инициализирует соединение с базой данных MySQL используя настройки из конфигурации.
//
// Что делает функция:
//   1. Получает конфигурацию через config.Get()
//   2. Проверяет, что используется MySQL (не Oracle)
//   3. Формирует строку подключения (DSN)
//   4. Открывает соединение с БД
//   5. Настраивает пул соединений (connection pool)
//   6. Проверяет соединение (ping)
//
// Если что-то пойдёт не так, программа завершится с ошибкой (log.Fatalf).
//
// ВАЖНО: перед вызовом Connect() необходимо вызвать config.Load(),
// иначе config.Get() вызовет панику.
//
// Пример использования:
//   config.Load("")
//   db.Connect()
//   // Теперь можно использовать db.DB для запросов
func Connect() {
	// Получаем загруженную конфигурацию
	cfg := config.Get()
	
	// Проверяем, что используется MySQL (Oracle пока не поддерживается)
	if cfg.Database.Engine != "mysql" {
		log.Fatalf("Unsupported database engine: %s", cfg.Database.Engine)
	}

	// Получаем строку подключения (Data Source Name)
	// Формат: "user:password@tcp(host:port)/database?charset=utf8mb4&parseTime=true"
	dsn := cfg.GetMySQLDSN()
	
	// Открываем соединение с базой данных
	// sql.Open() НЕ устанавливает реальное соединение, только готовит его
	// Реальное соединение установится при первом запросе
	var err error
	DB, err = sql.Open("mysql", dsn)
	if err != nil {
		// Если не удалось создать объект соединения, завершаем программу
		log.Fatalf("Failed to open database connection: %v", err)
	}

	// ============================================
	// Настройка пула соединений (Connection Pool)
	// ============================================
	// Пул соединений - это набор готовых соединений с БД, которые переиспользуются.
	// Это повышает производительность, т.к. не нужно каждый раз устанавливать новое соединение.
	
	mysqlCfg := cfg.Database.MySQL
	
	// SetMaxOpenConns - максимальное количество открытых соединений одновременно
	// Если все соединения заняты, новые запросы будут ждать освобождения
	// Рекомендуется: количество CPU * 2 + количество дисковых операций
	DB.SetMaxOpenConns(mysqlCfg.MaxConnections)
	
	// SetMaxIdleConns - максимальное количество неактивных соединений в пуле
	// Эти соединения готовы к использованию, но не выполняют запросы
	// Должно быть меньше MaxOpenConns
	DB.SetMaxIdleConns(mysqlCfg.MaxIdleConnections)
	
	// SetConnMaxLifetime - максимальное время жизни соединения
	// После этого времени соединение будет закрыто и создано новое
	// Это помогает избежать проблем с "мёртвыми" соединениями
	// Например, если MySQL сервер перезапустился, старые соединения станут невалидными
	DB.SetConnMaxLifetime(mysqlCfg.ConnMaxLifetime)
	
	// SetConnMaxIdleTime - максимальное время простоя соединения в пуле
	// Если соединение не использовалось N времени, оно будет закрыто
	// Это экономит ресурсы сервера БД
	DB.SetConnMaxIdleTime(mysqlCfg.ConnMaxIdleTime)

	// ============================================
	// Проверка соединения
	// ============================================
	// Ping() проверяет, что соединение действительно работает
	// Это первая реальная операция с БД, которая установит соединение
	if err = DB.Ping(); err != nil {
		// Если ping не прошёл (БД недоступна, неверные креды и т.д.), завершаем программу
		log.Fatalf("Failed to ping database: %v", err)
	}
	
	// Выводим сообщение об успешном подключении
	log.Printf("Connected to MySQL at %s:%d/%s", mysqlCfg.Host, mysqlCfg.Port, mysqlCfg.Database)
}

// Close закрывает соединение с базой данных.
// Рекомендуется вызывать при завершении работы приложения (graceful shutdown).
//
// Возвращает:
//   - error: ошибка при закрытии (если была)
//
// Пример использования:
//   defer db.Close() // Закроет соединение при завершении программы
func Close() error {
	if DB != nil {
		// Закрываем все соединения в пуле
		return DB.Close()
	}
	// Если DB == nil, значит Connect() не был вызван, ошибки нет
	return nil
}

// ============================================
// ФУНКЦИИ ДЛЯ РАБОТЫ С ТРАНЗАКЦИЯМИ
// ============================================
// Транзакция - это группа SQL запросов, которые выполняются как единое целое.
// Либо все запросы выполняются успешно (commit), либо все откатываются (rollback).
// Это гарантирует целостность данных.

// BeginTransaction начинает новую транзакцию.
//
// Что такое транзакция:
//   Транзакция позволяет выполнить несколько SQL запросов атомарно (как одно целое).
//   Если хотя бы один запрос не выполнится, все изменения откатятся.
//
// Зачем нужны транзакции:
//   Пример: создание пользователя и добавление его в группы.
//   Если пользователь создался, но добавление в группы не удалось,
//   то пользователь останется без групп - это ошибка.
//   С транзакцией: либо создастся пользователь И добавится в группы, либо ничего не произойдёт.
//
// Возвращает:
//   - *sql.Tx: объект транзакции для выполнения запросов
//   - error: ошибка, если не удалось начать транзакцию
//
// ВАЖНО:
//   - После использования транзакции ОБЯЗАТЕЛЬНО вызвать Commit() или Rollback()
//   - Если не вызвать, соединение с БД останется заблокированным
//   - Рекомендуется использовать defer для автоматического отката при ошибке
//
// Пример использования:
//
//	tx, err := db.BeginTransaction()
//	if err != nil {
//	    return err
//	}
//	defer tx.Rollback() // Откатим транзакцию, если что-то пойдёт не так
//
//	// Выполняем запросы в транзакции
//	_, err = tx.Exec("INSERT INTO users ...")
//	if err != nil {
//	    return err // defer tx.Rollback() выполнится автоматически
//	}
//
//	// Если всё успешно, подтверждаем транзакцию
//	return tx.Commit()
func BeginTransaction() (*sql.Tx, error) {
	// Проверяем, что соединение с БД установлено
	if DB == nil {
		return nil, fmt.Errorf("database connection not initialized, call Connect() first")
	}

	// Begin() начинает новую транзакцию
	// Получаем отдельное соединение из пула для этой транзакции
	// Все запросы в этой транзакции будут выполняться на одном соединении
	tx, err := DB.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}

	return tx, nil
}

// CommitTransaction подтверждает (сохраняет) транзакцию.
//
// Что делает:
//   Сохраняет все изменения, сделанные в транзакции, в базу данных.
//   После Commit() изменения становятся постоянными и видны другим соединениям.
//
// Параметры:
//   - tx: объект транзакции, полученный из BeginTransaction()
//
// Возвращает:
//   - error: ошибка, если не удалось подтвердить транзакцию
//
// ВАЖНО:
//   - После Commit() транзакция завершается, tx больше нельзя использовать
//   - Если Commit() не вызвать, изменения будут потеряны при закрытии соединения
//
// Пример использования:
//
//	tx, _ := db.BeginTransaction()
//	// ... выполняем запросы ...
//	if err := db.CommitTransaction(tx); err != nil {
//	    log.Printf("Failed to commit: %v", err)
//	}
func CommitTransaction(tx *sql.Tx) error {
	if tx == nil {
		return fmt.Errorf("transaction is nil")
	}

	// Commit() сохраняет все изменения в БД
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// RollbackTransaction откатывает (отменяет) транзакцию.
//
// Что делает:
//   Отменяет все изменения, сделанные в транзакции.
//   База данных вернётся в состояние, которое было до начала транзакции.
//
// Параметры:
//   - tx: объект транзакции, полученный из BeginTransaction()
//
// Возвращает:
//   - error: ошибка, если не удалось откатить транзакцию (редко случается)
//
// Когда использовать:
//   - При любой ошибке во время выполнения запросов в транзакции
//   - Когда нужно отменить изменения по бизнес-логике
//   - В defer для автоматического отката при панике
//
// Пример использования:
//
//	tx, _ := db.BeginTransaction()
//	defer db.RollbackTransaction(tx) // Автоматически откатит при ошибке
//
//	_, err := tx.Exec("INSERT INTO users ...")
//	if err != nil {
//	    return err // defer выполнит Rollback автоматически
//	}
//
//	// Если всё ОК, подтверждаем
//	return db.CommitTransaction(tx)
func RollbackTransaction(tx *sql.Tx) error {
	if tx == nil {
		// Если транзакция уже nil, значит она уже была закрыта
		// Это не ошибка, просто игнорируем
		return nil
	}

	// Rollback() отменяет все изменения
	if err := tx.Rollback(); err != nil {
		// Если ошибка "sql: transaction has already been committed or rolled back",
		// это означает, что транзакция уже была закрыта - это нормально
		if err.Error() != "sql: transaction has already been committed or rolled back" {
			return fmt.Errorf("failed to rollback transaction: %w", err)
		}
	}

	return nil
}

// GetLastInsertID возвращает ID последней вставленной записи.
//
// Что делает:
//   После INSERT запроса MySQL автоматически генерирует уникальный ID для новой записи.
//   Эта функция возвращает этот ID.
//
// Параметры:
//   - result: результат выполнения Exec() или аналогичной функции
//
// Возвращает:
//   - int64: ID последней вставленной записи
//   - error: ошибка, если не удалось получить ID
//
// Когда использовать:
//   - После INSERT запроса, когда нужно узнать ID созданной записи
//   - Например: создали пользователя и нужно узнать его ID для дальнейших операций
//
// Пример использования:
//
//	result, err := tx.Exec("INSERT INTO users (name) VALUES (?)", "John")
//	if err != nil {
//	    return err
//	}
//
//	userID, err := db.GetLastInsertID(result)
//	if err != nil {
//	    return err
//	}
//	log.Printf("Created user with ID: %d", userID)
func GetLastInsertID(result sql.Result) (int64, error) {
	// LastInsertId() возвращает ID последней вставленной записи
	id, err := result.LastInsertId()
	if err != nil {
		return 0, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return id, nil
}

// GetRowsAffected возвращает количество затронутых строк после UPDATE/DELETE.
//
// Что делает:
//   После UPDATE или DELETE запроса возвращает, сколько строк было изменено/удалено.
//
// Параметры:
//   - result: результат выполнения Exec()
//
// Возвращает:
//   - int64: количество затронутых строк
//   - error: ошибка, если не удалось получить количество
//
// Когда использовать:
//   - Для проверки, что запрос действительно изменил данные
//   - Например: обновление пользователя - проверить, что пользователь с таким ID существует
//
// Пример использования:
//
//	result, err := tx.Exec("UPDATE users SET name = ? WHERE id = ?", "New Name", userID)
//	if err != nil {
//	    return err
//	}
//
//	rowsAffected, err := db.GetRowsAffected(result)
//	if err != nil {
//	    return err
//	}
//
//	if rowsAffected == 0 {
//	    return fmt.Errorf("user with ID %d not found", userID)
//	}
func GetRowsAffected(result sql.Result) (int64, error) {
	// RowsAffected() возвращает количество изменённых/удалённых строк
	rows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get rows affected: %w", err)
	}

	return rows, nil
}
